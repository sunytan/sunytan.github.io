<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CoordinatorLayout+AppBarLayout+RecyclerView滑动吸顶原理解析</title>
    <url>/2021/05/13/CoordinatorLayout+AppBarLayout+RecyclerView%E6%BB%91%E5%8A%A8%E5%90%B8%E9%A1%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>​    本文主要介绍使用<code>AppBarLayout+RecyclerView</code>滑动吸顶布局，其滑动原理，以及如何禁止滑动，包括禁止滑动<code>AppBarLayout</code>本身滑动，以及禁止滑动<code>RecyclerView</code>而让<code>AppBarLayout</code>滑动的操作。</p>
<span id="more"></span> 

<p>​    先上图</p>
<p><img src="https://raw.githubusercontent.com/sunytan/sunytan.github.io.source/main/source/_posts/CoordinatorLayout%2BAppBarLayout%2BRecyclerView%E6%BB%91%E5%8A%A8%E5%90%B8%E9%A1%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/stickerbar_demo.gif" alt="图片"></p>
<h2 id="嵌套滑动原理"><a href="#嵌套滑动原理" class="headerlink" title="嵌套滑动原理"></a>嵌套滑动原理</h2><p>​    要达到如上效果，我们首先要知道其滑动原理，其主要还是使用了<code>NestedScrolling</code>的原理，<code>CoordinatorLayout</code>和<code>AppBarLayout</code>以及<code>RecyclerView</code>都实现了<code>NestedScrolling</code>的接口。主要是<code>NestedScrollingChildHelper</code>类和<code>NestedScrollingParent2</code>接口配合实现。还有<code>NestedScrollingParent3</code>只是在更高版本上的一些优化，此次不展开，有兴趣可以自行了解。</p>
<p><code>NestedScrollingChildHelper</code>：子view的嵌套滑动代理类，实现对其父View的嵌套滑动操作。</p>
<p><code>NestedScrollingParent2</code>：父view实现此接口，响应子view的嵌套滑动操作。</p>
<p>所以如果把<code>RecyclerView</code>换成<code>ListView</code>就无法达到滑动滑动吸顶的效果。因为<code>ListView</code>并没有实现此接口</p>
<h3 id="NestedScrolling接口"><a href="#NestedScrolling接口" class="headerlink" title="NestedScrolling接口"></a>NestedScrolling接口</h3><p>​    我们可以看下<code>NestedScrollingParent2</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由ViewGroup的子类实现，支持滑动操作能被其嵌套的子view代理</span></span><br><span class="line"><span class="comment"> * 实现这个接口的类，需要创建一个final的NestedScrollingParentHelper实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 当前嵌套滑动的开始，如果父View接受嵌套滑动，就需要返回true，否者此轮滑动仅仅子View自己处理</span></span><br><span class="line"><span class="comment">   * 开始滑动，返回true，才能滑动，才会有后续的回调</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接受了本轮嵌套滑动的回调通知，父View可以在接受后做自己的一些事情。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 停止滑动的回调，停止后调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 子View本身滑动之后，如果还有剩余的未消费的距离，交给父View进行嵌套滑动处理。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 子View本身滑动之前，预先交给父View处理嵌套滑动，父View把自身滑动消费的距离传回给子View</span></span><br><span class="line"><span class="comment">   * 子View再计算剩余还未消费的距离，然后子View再自己滑动剩下的距离</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView嵌套滑动实现"><a href="#RecyclerView嵌套滑动实现" class="headerlink" title="RecyclerView嵌套滑动实现"></a>RecyclerView嵌套滑动实现</h3><p>​    <code>RecyclerView</code>的滑动实现主要在于其<code>onTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 此处省略N行代码</span></span><br><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                mScrollPointerId = e.getPointerId(<span class="number">0</span>);</span><br><span class="line">                mInitialTouchX = mLastTouchX = (<span class="keyword">int</span>) (e.getX() + <span class="number">0.5f</span>);</span><br><span class="line">                mInitialTouchY = mLastTouchY = (<span class="keyword">int</span>) (e.getY() + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</span><br><span class="line">                <span class="keyword">if</span> (canScrollHorizontally) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (canScrollVertically) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 1.第一步</span></span><br><span class="line">              <span class="comment">// 开始嵌套滑动，初始化本次嵌套滑动的父View嵌套滑动状态。</span></span><br><span class="line">              <span class="comment">// 最终由NestedScrollingChildHelper.startNestedScroll代理方法实现其逻辑</span></span><br><span class="line">                startNestedScroll(nestedScrollAxis, TYPE_TOUCH);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN: &#123;</span><br><span class="line">                mScrollPointerId = e.getPointerId(actionIndex);</span><br><span class="line">                mInitialTouchX = mLastTouchX = (<span class="keyword">int</span>) (e.getX(actionIndex) + <span class="number">0.5f</span>);</span><br><span class="line">                mInitialTouchY = mLastTouchY = (<span class="keyword">int</span>) (e.getY(actionIndex) + <span class="number">0.5f</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// ... 此处省略N行代码</span></span><br><span class="line">                <span class="keyword">if</span> (mScrollState == SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    mReusableIntPair[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    mReusableIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                  <span class="comment">// 2.第二步</span></span><br><span class="line">                  <span class="comment">// 分发嵌套预滑动，传入mReusableIntPair数组。</span></span><br><span class="line">                  <span class="comment">// 数组记录被嵌套父view消费的滑动距离，最后返回出来。以此来计算自己需要滑动的距离</span></span><br><span class="line">                  <span class="comment">// 此处的父View其实就是CoordinatorLayout</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchNestedPreScroll(</span><br><span class="line">                            canScrollHorizontally ? dx : <span class="number">0</span>,</span><br><span class="line">                            canScrollVertically ? dy : <span class="number">0</span>,</span><br><span class="line">                            mReusableIntPair, mScrollOffset, TYPE_TOUCH</span><br><span class="line">                    )) &#123;</span><br><span class="line">                        dx -= mReusableIntPair[<span class="number">0</span>];</span><br><span class="line">                        dy -= mReusableIntPair[<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// Updated the nested offsets</span></span><br><span class="line">                        mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                        mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// Scroll has initiated, prevent parents from intercepting</span></span><br><span class="line">                        getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mLastTouchX = x - mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mLastTouchY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 3.第三步</span></span><br><span class="line">                  <span class="comment">// RecyclerView内部自己滑动，自己滑动上一步的嵌套预滑动之后剩下的滑动距离。</span></span><br><span class="line">                  <span class="comment">// 如果全被外部父view消费掉，则自己无法滑动。</span></span><br><span class="line">                  <span class="comment">// 同样，其实里面还有判断如果RecyclerView以及滑动到边界了，同样还要分发给父view处理。</span></span><br><span class="line">                    <span class="keyword">if</span> (scrollByInternal(</span><br><span class="line">                            canScrollHorizontally ? dx : <span class="number">0</span>,</span><br><span class="line">                            canScrollVertically ? dy : <span class="number">0</span>,</span><br><span class="line">                            e)) &#123;</span><br><span class="line">                        getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mGapWorker != <span class="keyword">null</span> &amp;&amp; (dx != <span class="number">0</span> || dy != <span class="number">0</span>)) &#123;</span><br><span class="line">                        mGapWorker.postFromTraversal(<span class="keyword">this</span>, dx, dy);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">// ... 此处省略N行代码</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先看第一步<code>startNestedScroll</code>的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 就如前面所说就是用NestedScrollingChildHelper这个代理真正实现的。</span></span><br><span class="line">    <span class="keyword">return</span> getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    其就是<code>NestedScrollingChildHelper</code>这个代理真正来实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNestedScrollingParent(type)) &#123;</span><br><span class="line">            <span class="comment">// Already in progress</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  	<span class="comment">// 1.此处由RecyclerView自己设置的是否允许嵌套滑动。</span></span><br><span class="line">  	<span class="comment">// 可以通过此处设置禁止嵌套滑动，从而实现只滑动RecyclerView本身</span></span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;</span><br><span class="line">            ViewParent p = mView.getParent(); <span class="comment">// 此处ViewParent就是CoordinatorLayout</span></span><br><span class="line">            View child = mView; <span class="comment">// RecyclerView本身</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 2.此处其实就是交由父View来处理，返回值代表是否开始此轮的嵌套滑动</span></span><br><span class="line">              	<span class="comment">// 其实就是父View对NestedScrollingParent2接口的实现</span></span><br><span class="line">                <span class="keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes, type)) &#123;</span><br><span class="line">                  <span class="comment">// 如果父View接受此次嵌套滑动，就设置此轮的嵌套滑动父View实例</span></span><br><span class="line">                    setNestedScrollingParentForType(type, p);</span><br><span class="line">                  <span class="comment">// 回调父View接受了此次嵌套滑动</span></span><br><span class="line">                    ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                    child = (View) p;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.getParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    从上面的代码注释已经能看出了，两种禁止嵌套滑动的方式。</p>
<pre><code> 1. 通过RecyclerView.setNestedScrollingEnabled方法
 2. 通过重写父View的onStartNestedScroll方法让其返回false
</code></pre>
<ul>
<li><p>接下来看第二步<code>dispatchNestedPreScroll</code>方法：</p>
<p>其实就是<code>NestedScrollingChildHelper</code>的<code>dispatchNestedPreScroll</code>来实现的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> <span class="keyword">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此和上面一样就是RecyclerView中设置是否允许嵌套滑动</span></span><br><span class="line">    <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;</span><br><span class="line">      	<span class="comment">// 获取嵌套滑动的父View，在startNestedScroll中已经赋值过，此处就是CoordinatorLayout</span></span><br><span class="line">        <span class="keyword">final</span> ViewParent parent = getNestedScrollingParentForType(type);</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (consumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                consumed = getTempNestedScrollConsumed();</span><br><span class="line">            &#125;</span><br><span class="line">            consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            consumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 此处就是真正的父view处理预滑动，通过consumed这个数组传递，来得到父view消费掉的距离</span></span><br><span class="line">          <span class="comment">// 使用数组对象传递而不是用的所谓返回值。也一样带出结果</span></span><br><span class="line">            ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中关键步骤注释都写的很清楚了。</p>
<p><strong>这个方法其实就一个用处：</strong> 调用父view的<code>onNestedPreScroll</code>接口通过传入的数组来得到父view消费了多少滑动距离。</p>
<ul>
<li>再接下来看下第三步其内部滑动<code>scrollByInternal</code> ：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollByInternal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unconsumedX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unconsumedY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> consumedX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> consumedY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    consumePendingUpdateOperations();</span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReusableIntPair[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        mReusableIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// RecyclerView自己的滑动步骤，使用mReusableIntPair数组来记录滑动消费的距离</span></span><br><span class="line">        scrollStep(x, y, mReusableIntPair);</span><br><span class="line">      <span class="comment">// 得到x,y两个方向的消费距离</span></span><br><span class="line">        consumedX = mReusableIntPair[<span class="number">0</span>];</span><br><span class="line">        consumedY = mReusableIntPair[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 剩下的未消费的距离</span></span><br><span class="line">        unconsumedX = x - consumedX;</span><br><span class="line">        unconsumedY = y - consumedY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mReusableIntPair[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    mReusableIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 分发嵌套滑动，再RecyclerView自己滑动之后，剩下的滑动距离再次分发给父view</span></span><br><span class="line">    dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset,</span><br><span class="line">            TYPE_TOUCH, mReusableIntPair);</span><br><span class="line">  <span class="comment">// 同样通过mReusableIntPair数组得到父view滑动消费的距离</span></span><br><span class="line">    unconsumedX -= mReusableIntPair[<span class="number">0</span>];</span><br><span class="line">    unconsumedY -= mReusableIntPair[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span> consumedNestedScroll = mReusableIntPair[<span class="number">0</span>] != <span class="number">0</span> || mReusableIntPair[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the last touch co-ords, taking any scroll offset into account</span></span><br><span class="line">    mLastTouchX -= mScrollOffset[<span class="number">0</span>];</span><br><span class="line">    mLastTouchY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">    mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">    mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev != <span class="keyword">null</span> &amp;&amp; !MotionEventCompat.isFromSource(ev, InputDevice.SOURCE_MOUSE)) &#123;</span><br><span class="line">            pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);</span><br><span class="line">        &#125;</span><br><span class="line">        considerReleasingGlowsOnScroll(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// RecyclerView的自己滑动，分发</span></span><br><span class="line">        dispatchOnScrolled(consumedX, consumedY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consumedNestedScroll || consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看上面代码注释，此方法主要作用作用：</p>
<pre><code>1. 先滑动`RecyclerView`本身。
 2. 然后把剩余的未消费滑动距离再分发给到父view进行滑动。
</code></pre>
<h3 id="子RecyclerView嵌套滑动总结"><a href="#子RecyclerView嵌套滑动总结" class="headerlink" title="子RecyclerView嵌套滑动总结"></a>子<code>RecyclerView</code>嵌套滑动总结</h3><p>​    从上面可以看到嵌套滑动的子View的整体嵌套滑动步骤分为三大步：</p>
<p><strong>第一步:</strong> <code>startNestedScroll</code></p>
<p>​    开启本轮嵌套滑动，调用父view实现的<code>NestedScrollingParent2.onStartNestedScroll</code>接口</p>
<p><strong>第二步:</strong>  <code>dispatchNestedPreScroll</code> </p>
<p>​        分发嵌套预滑动，把滑动距离预先分发给父view，父view自己处理决定是否消费。</p>
<p>​        这里主要是调用了父类实现的``NestedScrollingParent2.onNestedPreScroll` 接口</p>
<p>​        所以滑动<code>RecyclerView</code>的时候，先响应头还是先响应本身正是基于此方法实现的。</p>
<p><strong>第三步:</strong> <code>scrollByInternal</code></p>
<p>​        <code>RecyclerView</code>自己内部滑动未被父view消费的距离。</p>
<p>​        自身滑动后，再把还剩下的未消费的距离再次分发给到父布局。父布局可以再次进行消费。</p>
<p>​        这里主要调用父类实现的 <code>NestedScrollingParent2.onNestedScroll</code></p>
<p>到此嵌套滑动<code>NestedScrollingParent2</code>的滑动接口以及全部用到了。</p>
<h3 id="父CoordinatorLayout嵌套滑动实现"><a href="#父CoordinatorLayout嵌套滑动实现" class="headerlink" title="父CoordinatorLayout嵌套滑动实现"></a>父<code>CoordinatorLayout</code>嵌套滑动实现</h3><p>​    上面以及完整讲过子<code>RecyclerView</code>嵌套滑动的整个步骤，其最终都会调用到父view的嵌套滑动接口。接下来在按照其先后顺序看下父view的嵌套滑动的接口实现。</p>
<p>​    首先来看下<code>onStartNestedScroll</code>的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> axes, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 由此其实父布局CoordinatorLayout并不是滑动本身，而是继续滑动其所有子布局</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">      <span class="comment">// 不可见的子布局不参与嵌套滑动</span></span><br><span class="line">        <span class="keyword">if</span> (view.getVisibility() == View.GONE) &#123;</span><br><span class="line">            <span class="comment">// If it&#x27;s GONE, don&#x27;t dispatch</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">      <span class="comment">// 其子view布局中必须实现layout_behavior，才能实现嵌套滑动</span></span><br><span class="line">      <span class="comment">// 所以本例中的悬浮按钮因为没有实现behavior，不会跟随嵌套滑动。</span></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 调用其behavior中的onStartNestedScroll，根据其不同的行为决定当前子view是否接受嵌套滑动</span></span><br><span class="line">          <span class="comment">// 所以AppBarLayout的嵌套滑动完全交由AppBarLayout.Behavior处理，本例中使用了自定义的MyBehavior</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> accepted = viewBehavior.onStartNestedScroll(<span class="keyword">this</span>, view, child,</span><br><span class="line">                    target, axes, type);</span><br><span class="line">            handled |= accepted;</span><br><span class="line">            lp.setNestedScrollAccepted(type, accepted);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lp.setNestedScrollAccepted(type, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上又有一种禁止嵌套滑动的的方法</p>
<p>1 .  自定义<code>AppBarLayout</code>的Behavior，使<code>onStartNestedScroll</code> 返回false，则此子View不会进行嵌套滑动。</p>
<p>接下来再来看<code>onNestedPreScroll</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>  type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> yConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由此其实父布局CoordinatorLayout并不是滑动本身，而是继续滑动其所有子View</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (view.getVisibility() == GONE) &#123;</span><br><span class="line">            <span class="comment">// If the child is GONE, skip...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">      <span class="comment">// 此处onStartNestedScroll中进行了赋值，判断是否接受嵌套滑动</span></span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted(type)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBehaviorConsumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            mBehaviorConsumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 子view的嵌套滑动完全交由其Behavior处理，本例也就是AppBarLayout.Behavior</span></span><br><span class="line">            viewBehavior.onNestedPreScroll(<span class="keyword">this</span>, view, target, dx, dy, mBehaviorConsumed, type);</span><br><span class="line"></span><br><span class="line">            xConsumed = dx &gt; <span class="number">0</span> ? Math.max(xConsumed, mBehaviorConsumed[<span class="number">0</span>])</span><br><span class="line">                    : Math.min(xConsumed, mBehaviorConsumed[<span class="number">0</span>]);</span><br><span class="line">            yConsumed = dy &gt; <span class="number">0</span> ? Math.max(yConsumed, mBehaviorConsumed[<span class="number">1</span>])</span><br><span class="line">                    : Math.min(yConsumed, mBehaviorConsumed[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            accepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处就是数组存储已经嵌套滑动预先消费掉的距离，通过此数组对象带回去给了RecyclerView的mReusableIntPair</span></span><br><span class="line">    consumed[<span class="number">0</span>] = xConsumed;</span><br><span class="line">    consumed[<span class="number">1</span>] = yConsumed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">        onChildViewsChanged(EVENT_NESTED_SCROLL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从上述代码可以看出，在父View的<code>onNestedPreScroll</code>中，主要是调用子类的Behavior的<code>onNestedPreScroll</code>方法，由子类的Behavior真正实现如何响应滑动，子View进行滑动后会把自己消费了多少距离，通过数组传回给到了最初的子View也就是<code>RecyclerView</code></p>
<p>​    其实对于AppBarLayout如何嵌套滑动完全都可以由我们自己自定义。</p>
<p>再接下来我们看下<code>onNestedScroll</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@ViewCompat</span>.NestedScrollType <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> xConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> yConsumed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 整个处理过程其实跟onNestedPreScroll一样。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (view.getVisibility() == GONE) &#123;</span><br><span class="line">            <span class="comment">// If the child is GONE, skip...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted(type)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            mBehaviorConsumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            mBehaviorConsumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            viewBehavior.onNestedScroll(<span class="keyword">this</span>, view, target, dxConsumed, dyConsumed,</span><br><span class="line">                    dxUnconsumed, dyUnconsumed, type, mBehaviorConsumed);</span><br><span class="line"></span><br><span class="line">            xConsumed = dxUnconsumed &gt; <span class="number">0</span> ? Math.max(xConsumed, mBehaviorConsumed[<span class="number">0</span>])</span><br><span class="line">                    : Math.min(xConsumed, mBehaviorConsumed[<span class="number">0</span>]);</span><br><span class="line">            yConsumed = dyUnconsumed &gt; <span class="number">0</span> ? Math.max(yConsumed, mBehaviorConsumed[<span class="number">1</span>])</span><br><span class="line">                    : Math.min(yConsumed, mBehaviorConsumed[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            accepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumed[<span class="number">0</span>] += xConsumed;</span><br><span class="line">    consumed[<span class="number">1</span>] += yConsumed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">        onChildViewsChanged(EVENT_NESTED_SCROLL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从上述代码可以看到<code>onNestedScroll</code>和<code>onNestedPreScroll</code>的处理过程基本一样，本来也都是处理<code>AppBarLayout</code>的滑动，只是处理的时机不一样罢了。</p>
<p>到此整个嵌套滑动的过程以及很清晰了。</p>
<p>下面附上时序图：</p>
<p><img src="https://raw.githubusercontent.com/sunytan/sunytan.github.io.source/main/source/_posts/CoordinatorLayout%2BAppBarLayout%2BRecyclerView%E6%BB%91%E5%8A%A8%E5%90%B8%E9%A1%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    以上是以<code>RecyclerView</code>为例，讲述的原理流程，其实也可以替换成任何实现了嵌套滑动接口的View。关于如何禁止滑动其实在过程中已经讲的很清楚了。没有再细讲如何实现吸顶的，其实想想也能就能明白，吸顶其实就是上滑的时候，滑到一定距离就不让<code>AppBarLayout</code>上移了。那其实就是可以通过其本身滑动的Behavior控制其可滑动距离罢了。当然其实<code>AppBarLayout</code>本身已经实现好了，其通过给其子View设置<code>layout_scrollFlags</code>来控制其滑动行为。这个在此不展开了。</p>
<p>本地使用示例代码地址：<a href="https://github.com/sunytan/StickerBarDemo/">https://github.com/sunytan/StickerBarDemo/</a></p>
]]></content>
      <categories>
        <category>Android UI</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2022/10/28/Mac%E7%BC%96%E8%AF%91Android%20%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1>
  <center>Mac编译查看Android 源码记录</center>
</h1>
## 一、环境准备

<p>最常见的坑就是Mac系统大小写不敏感。打开Mac磁盘工具，添加一个卷宗，格式选择区分大小写，大小选项可以不同填</p>
<p>![磁盘添加大小写敏感卷宗](Mac编译Android 源码记录/磁盘添加大小写敏感卷宗.png)</p>
<h2 id="二、获取Android源代码"><a href="#二、获取Android源代码" class="headerlink" title="二、获取Android源代码"></a>二、获取Android源代码</h2><p>鉴于国内都被墙的情况下，没法直接从google官方获取，通常都会走国内的几大开源镜像站。</p>
<p>我就是从清华的镜像站获取的，具体步骤我就不重复写了，请参考<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>
<p>镜像站上的源代码细分没有到最新，对于最新的源代码的分支细分，请参考<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds">Android源代码细分版本</a></p>
<h2 id="三、编译idegen"><a href="#三、编译idegen" class="headerlink" title="三、编译idegen"></a>三、编译idegen</h2><p><strong>使用命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">make idegen</span><br></pre></td></tr></table></figure>

<p>然后会出现如下错误：</p>
<p>![android源码编译没有支持的sdk](Mac编译Android 源码记录/android源码编译没有支持的sdk.png)</p>
<p>原因是当前下载的Xcode版本所支持的Mac SDK，不在源码要求的范围内。</p>
<p>参考这个:<a href="https://stackoverflow.com/questions/50760701/could-not-find-a-supported-mac-sdk-10-10-10-11-10-12-10-13">https://stackoverflow.com/questions/50760701/could-not-find-a-supported-mac-sdk-10-10-10-11-10-12-10-13</a></p>
<p>可以从 <a href="https://github.com/phracker/MacOSX-SDKs">https://github.com/phracker/MacOSX-SDKs</a> 这个网址上下载报错提示所需的SDK</p>
<p>然后把下载的SDK解压到<a href="">/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</a>这个目录下。</p>
<p>如下所示</p>
<p>![xcode sdk版本](Mac编译Android 源码记录/xcode sdk版本.png)</p>
<p>解决上述错误后，又出现如下错误：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">============================================</span><br><span class="line"><span class="meta">[100%</span><span class="bash"> 11/11] out/soong/.bootstrap/bin/soong_build out/soong/build.ninja</span></span><br><span class="line">FAILED: out/soong/build.ninja</span><br><span class="line">out/soong/.bootstrap/bin/soong_build -t -l out/.module_paths/Android.bp.list -b out/soong -n out -d out/soong/build.ninja.d -globFile out/soong/.bootstrap/build-globs.ninja -o out/soong/build.ninja Android.bp</span><br><span class="line">error: external/v8/Android.bp:181:16: module &quot;v8_bytecode_builtins_list_generator&quot; variant &quot;darwin_x86_64&quot;: host_ldlibs: Host library `-lrt` not available</span><br><span class="line">error: external/v8/Android.bp:209:16: module &quot;v8_torque&quot; variant &quot;darwin_x86_64&quot;: host_ldlibs: Host library `-lrt` not available</span><br><span class="line">10:48:14 soong bootstrap failed with: exit status 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### failed to build some targets (01:18 (mm:ss)) ####</span></span></span><br></pre></td></tr></table></figure>

<p>问题原因：</p>
<p><a href="https://stackoverflow.com/questions/47703239/ld-library-not-found-for-lrt">https://stackoverflow.com/questions/47703239/ld-library-not-found-for-lrt</a></p>
<p>这是因为在新的glibc中用不到-lrt，所以把对应报错的Android.bp中-lrt移除掉就可以了。</p>
<p>然后出现 <strong>too many open files</strong>的错误</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">FAILED: out/soong/build.ninja</span><br><span class="line">out/soong/.bootstrap/bin/soong_build -t -l out/.module_paths/Android.bp.list -b out/soong -n out -d out/soong/build.ninja.d -globFile out/soong/.bootstrap/build-globs.ninja -o out/soong/build.ninja Android.bp</span><br><span class="line">error: external/avb/Android.bp:100:1: module &quot;aftl_proto&quot; variant &quot;darwin_x86_64_PY2&quot;: glob: open /Volumes/Code/aosp/external/avb/proto: too many open files</span><br><span class="line">error: external/avb/Android.bp:100:1: module &quot;aftl_proto&quot; variant &quot;darwin_x86_64_PY2&quot;: doesn&#x27;t have any source files!</span><br><span class="line">error: external/python/uritemplates/uritemplate/Android.bp:14:1: module &quot;py-uritemplate&quot; variant &quot;darwin_x86_64_PY2&quot;: doesn&#x27;t have any source files!</span><br><span class="line">error: cts/tests/framework/base/windowmanager/translucentapp/Android.bp:15:1: module &quot;cts-wm-translucent-app&quot;: glob: open /Volumes/Code/aosp/cts/tests/framework/base/windowmanager/translucentapp/src: too many open files</span><br><span class="line">error: cts/tests/framework/base/windowmanager/Android.bp:15:1: module &quot;cts-wm-components&quot;: glob: open /Volumes/Code/aosp/cts/tests/framework/base/windowmanager: too many open files</span><br><span class="line">error: cts/tests/framework/base/windowmanager/app_base/Android.bp:15:1: module &quot;cts-wm-components-base&quot;: glob: open /Volumes/Code/aosp/cts/tests/framework/base/windowmanager/app_base: too many open files</span><br><span class="line">error: external/python/funcsigs/funcsigs/Android.bp:15:1: module &quot;py-funcsigs&quot; variant &quot;darwin_x86_64_PY2&quot;: doesn&#x27;t have any source files!</span><br><span class="line">error: frameworks/base/services/wifi/Android.bp:1:1: module &quot;services.wifi-sources&quot;: glob: fcntl: too many open files</span><br><span class="line">error: external/hamcrest/hamcrest-core/Android.bp:17:1: module &quot;hamcrest&quot; variant &quot;darwin_common&quot;: glob: fcntl: too many open files</span><br><span class="line">error: cts/libs/testserver/Android.bp:15:1: module &quot;ctstestserver&quot; variant &quot;android_common&quot;: glob: fcntl: too many open files</span><br><span class="line">error: frameworks/base/services/voiceinteraction/Android.bp:1:1: module &quot;services.voiceinteraction-sources&quot;: glob: fcntl: too many open files</span><br><span class="line">error: cts/tests/signature/lib/common/Android.bp:15:1: module &quot;signature-common-javalib&quot; variant &quot;darwin_common&quot;: glob: fcntl: too many open files</span><br><span class="line">error: external/jcommander/Android.bp:21:1: module &quot;jcommander&quot; variant &quot;darwin_common&quot;: glob: fcntl: too many open files</span><br><span class="line">error: external/python/asn1crypto/asn1crypto/Android.bp:14:1: module &quot;py-asn1crypto&quot; variant &quot;darwin_x86_64_PY2&quot;: doesn&#x27;t have any source files!</span><br><span class="line">error: platform_testing/libraries/annotations/Android.bp:17:1: module &quot;platform-test-annotations&quot; variant &quot;darwin_common&quot;: glob: fcntl: too many open files</span><br><span class="line">error: external/snakeyaml/Android.bp:46:1: module &quot;snakeyaml&quot; variant &quot;darwin_common&quot;: glob: fcntl: too many open files</span><br><span class="line">error: frameworks/base/core/res/Android.bp:57:1: module &quot;robolectric_framework_raw_res_files&quot;: glob: fcntl: too many open files</span><br><span class="line">11:35:40 soong bootstrap failed with: exit status 1</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### failed to build some targets (22 seconds) ####</span></span></span><br></pre></td></tr></table></figure>

<p>这是因为打开了太多文件，主要是和系统配置有关。</p>
<p>可以使用如下命令查看</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">launchctl limit</span><br></pre></td></tr></table></figure>

<p>结果如下显示，其中maxfiles就是最大打开文件数限制</p>
<p>![image-20210916113944468](Mac编译Android 源码记录/file_limit.png)</p>
<p>临时修改大小限制：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">ulimit -S -n 1024</span><br></pre></td></tr></table></figure>

<p>这样之后，编译idegen总算成功了。</p>
<h2 id="四、导入Android-Studio查看"><a href="#四、导入Android-Studio查看" class="headerlink" title="四、导入Android Studio查看"></a>四、导入Android Studio查看</h2><p><strong>首先生成AndroidStudio所需要的android.ipr和android.iml</strong></p>
<p>使用上面idegen编译好的文件，使用如下命令，就可以生成所需的配置文件</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">./development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>

<p>因为我们仅仅需要看framework相关源码。所以一些不必要的文件都排除掉，减少androidstuido 导入时长。需要在android.iml文件中加入如下一些代码</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/art&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/bionic&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/bootable&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/build&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/cts&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/dalvik&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/developers&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/development&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/device&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/docs&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/external&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/hardware&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/kernel&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/libcore&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/libnativehelper&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/out&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/pdk&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/platform_testing&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/prebuilts&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/sdk&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/system&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/test&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/toolchain&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/tools&quot; /&gt;</span><br><span class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/.repo&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>然后open an exist project 打开android.ipr。</p>
]]></content>
  </entry>
  <entry>
    <title>前言</title>
    <url>/2022/10/28/%E5%89%8D%E8%A8%80md/</url>
    <content><![CDATA[<p>做安卓开发也好几年了，一直也没习惯去记录下来自己的一些学习与理解，导致很多东西总是学了忘，忘了学。建此博客只为了记录下来一些日常的心得以及分析理解，方便自己的加深记忆，也方便同行一起学习，避免遇到重复的坑。</p>
<span id="more"></span>

]]></content>
  </entry>
</search>
